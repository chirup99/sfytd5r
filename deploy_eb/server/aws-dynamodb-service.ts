import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { 
  DynamoDBDocumentClient, 
  PutCommand, 
  GetCommand, 
  ScanCommand, 
  DeleteCommand,
  QueryCommand,
  UpdateCommand
} from "@aws-sdk/lib-dynamodb";

const TABLE_NAME = "tradebook-heatmaps";

class AWSDynamoDBService {
  private client: DynamoDBClient | null = null;
  private docClient: DynamoDBDocumentClient | null = null;
  private isInitialized: boolean = false;

  constructor() {
    this.initialize();
  }

  private initialize() {
    const accessKeyId = process.env.AWS_ACCESS_KEY_ID?.trim();
    const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY?.trim();
    const region = (process.env.AWS_REGION || "eu-north-1").trim();

    if (!accessKeyId || !secretAccessKey) {
      console.log("‚ö†Ô∏è AWS credentials not found in environment variables");
      console.log("   Required: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION");
      return;
    }

    console.log(`üîê AWS Credentials check:`);
    console.log(`   Access Key ID: ${accessKeyId.substring(0, 4)}...${accessKeyId.substring(accessKeyId.length - 4)} (${accessKeyId.length} chars)`);
    console.log(`   Secret Key: ****${secretAccessKey.substring(secretAccessKey.length - 4)} (${secretAccessKey.length} chars)`);
    console.log(`   Region: ${region}`);

    try {
      this.client = new DynamoDBClient({
        region: region,
        credentials: {
          accessKeyId: accessKeyId,
          secretAccessKey: secretAccessKey
        }
      });

      this.docClient = DynamoDBDocumentClient.from(this.client, {
        marshallOptions: {
          removeUndefinedValues: true,
          convertEmptyValues: true
        }
      });

      this.isInitialized = true;
      console.log(`‚úÖ AWS DynamoDB initialized successfully`);
      console.log(`   Region: ${region}`);
      console.log(`   Table: ${TABLE_NAME}`);
    } catch (error) {
      console.error("‚ùå Failed to initialize AWS DynamoDB:", error);
    }
  }

  isConnected(): boolean {
    return this.isInitialized && this.docClient !== null;
  }

  async saveJournalData(dateKey: string, data: any): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const command = new PutCommand({
        TableName: TABLE_NAME,
        Item: {
          dateKey: dateKey,
          data: data,
          updatedAt: new Date().toISOString()
        }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Saved journal data for ${dateKey}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to save journal data for ${dateKey}:`, error);
      return false;
    }
  }

  async getJournalData(dateKey: string): Promise<any | null> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return null;
    }

    try {
      const command = new GetCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: dateKey }
      });

      const response = await this.docClient!.send(command);

      if (response.Item) {
        console.log(`‚úÖ AWS: Retrieved journal data for ${dateKey}`);
        return response.Item.data;
      }

      console.log(`‚ö†Ô∏è AWS: No data found for ${dateKey}`);
      return null;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to get journal data for ${dateKey}:`, error);
      return null;
    }
  }

  async getAllJournalData(): Promise<Record<string, any>> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return {};
    }

    try {
      const command = new ScanCommand({
        TableName: TABLE_NAME
      });

      const response = await this.docClient!.send(command);

      const result: Record<string, any> = {};
      const today = new Date().toISOString().split('T')[0]; // 2025-12-12 format

      if (response.Items) {
        for (const item of response.Items) {
          if (item.dateKey && item.data) {
            // ‚úÖ CRITICAL FIX: Skip user-specific journal entries (personal heatmap data)
            // These keys start with "user_" and should NOT be processed by getAllJournalData()
            // They have their own function: getAllUserJournalData()
            if (item.dateKey.startsWith('user_')) {
              continue; // Skip personal heatmap data - do not modify or delete
            }
            
            let cleanKey = item.dateKey.replace('journal_', '');
            
            // Fix invalid dates (empty, null, or non-date format) - only for demo data
            const isValidDate = /^\d{4}-\d{2}-\d{2}$/.test(cleanKey);
            if (!isValidDate) {
              console.log(`‚ö†Ô∏è Invalid date key detected: "${cleanKey}" - replacing with today: ${today}`);
              cleanKey = today;
              // Update the item in database with fixed date
              await this.saveJournalData(`journal_${today}`, item.data);
              // Delete the old invalid entry
              await this.deleteJournalData(item.dateKey);
            }
            
            result[cleanKey] = item.data;
          }
        }
        console.log(`‚úÖ AWS: Retrieved ${Object.keys(result).length} demo journal entries`);
      }

      return result;
    } catch (error) {
      console.error("‚ùå AWS: Failed to get all journal data:", error);
      return {};
    }
  }

  async deleteJournalData(dateKey: string): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const command = new DeleteCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: dateKey }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Deleted journal data for ${dateKey}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to delete journal data for ${dateKey}:`, error);
      return false;
    }
  }

  async getCachedData(key: string): Promise<any | null> {
    return this.getJournalData(key);
  }

  async setCachedData(key: string, data: any): Promise<boolean> {
    return this.saveJournalData(key, data);
  }

  async getAllCollectionData(): Promise<Record<string, any>> {
    return this.getAllJournalData();
  }

  // ========================================
  // USER-SPECIFIC JOURNAL METHODS (Personal Heatmap)
  // Key format: user_{userId}_{YYYY-MM-DD}
  // ========================================

  async saveUserJournalData(userId: string, dateKey: string, data: any): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const userDateKey = `user_${userId}_${dateKey}`;
      const command = new PutCommand({
        TableName: TABLE_NAME,
        Item: {
          dateKey: userDateKey,
          userId: userId,
          date: dateKey,
          sessionDate: dateKey, // Required for GSI userId-sessionDate-index
          data: data,
          updatedAt: new Date().toISOString()
        }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Saved user journal data for ${userId}/${dateKey}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to save user journal data for ${userId}/${dateKey}:`, error);
      return false;
    }
  }

  async getUserJournalData(userId: string, dateKey: string): Promise<any | null> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return null;
    }

    try {
      const userDateKey = `user_${userId}_${dateKey}`;
      const command = new GetCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: userDateKey }
      });

      const response = await this.docClient!.send(command);

      if (response.Item) {
        console.log(`‚úÖ AWS: Retrieved user journal data for ${userId}/${dateKey}`);
        return response.Item.data;
      }

      console.log(`‚ö†Ô∏è AWS: No user data found for ${userId}/${dateKey}`);
      return null;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to get user journal data for ${userId}/${dateKey}:`, error);
      return null;
    }
  }

  async getAllUserJournalData(userId: string): Promise<Record<string, any>> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return {};
    }

    try {
      const userPrefix = `user_${userId}_`;
      
      // Try using GSI userId-sessionDate-index for efficient lookup
      try {
        const queryCommand = new QueryCommand({
          TableName: TABLE_NAME,
          IndexName: 'userId-sessionDate-index',
          KeyConditionExpression: "userId = :userId",
          ExpressionAttributeValues: {
            ":userId": userId
          }
        });
        
        const response = await this.docClient!.send(queryCommand);
        const result: Record<string, any> = {};

        if (response.Items) {
          for (const item of response.Items) {
            if (item.dateKey && item.data) {
              const cleanKey = item.dateKey.replace(userPrefix, '');
              result[cleanKey] = item.data;
            }
          }
          console.log(`‚úÖ AWS: Retrieved ${Object.keys(result).length} user journal entries for ${userId} (GSI)`);
        }
        return result;
      } catch (gsiError: any) {
        // Fallback to scan if GSI doesn't exist
        if (gsiError.message?.includes('index') || gsiError.name === 'ValidationException') {
          console.log('‚ö†Ô∏è GSI not found, using scan fallback for getAllUserJournalData');
        } else {
          throw gsiError;
        }
      }

      // Fallback to scan
      const scanCommand = new ScanCommand({
        TableName: TABLE_NAME,
        FilterExpression: "begins_with(dateKey, :prefix)",
        ExpressionAttributeValues: {
          ":prefix": userPrefix
        }
      });

      const response = await this.docClient!.send(scanCommand);

      const result: Record<string, any> = {};

      if (response.Items) {
        for (const item of response.Items) {
          if (item.dateKey && item.data) {
            const cleanKey = item.dateKey.replace(userPrefix, '');
            result[cleanKey] = item.data;
          }
        }
        console.log(`‚úÖ AWS: Retrieved ${Object.keys(result).length} user journal entries for ${userId}`);
      }

      return result;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to get all user journal data for ${userId}:`, error);
      return {};
    }
  }

  async deleteUserJournalData(userId: string, dateKey: string): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const userDateKey = `user_${userId}_${dateKey}`;
      const command = new DeleteCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: userDateKey }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Deleted user journal data for ${userId}/${dateKey}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to delete user journal data for ${userId}/${dateKey}:`, error);
      return false;
    }
  }

  // ========================================
  // USER-SPECIFIC PAPER TRADING METHODS
  // Key format: paper_trading_{userId}
  // ========================================

  async savePaperTradingData(userId: string, data: {
    capital: number;
    positions: any[];
    tradeHistory: any[];
    totalPnl: number;
    realizedPnl: number;
  }): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const paperTradingKey = `paper_trading_${userId}`;
      const command = new PutCommand({
        TableName: TABLE_NAME,
        Item: {
          dateKey: paperTradingKey,
          userId: userId,
          data: data,
          updatedAt: new Date().toISOString()
        }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Saved paper trading data for user ${userId}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to save paper trading data for user ${userId}:`, error);
      return false;
    }
  }

  async getPaperTradingData(userId: string): Promise<{
    capital: number;
    positions: any[];
    tradeHistory: any[];
    totalPnl: number;
    realizedPnl: number;
  } | null> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return null;
    }

    try {
      const paperTradingKey = `paper_trading_${userId}`;
      const command = new GetCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: paperTradingKey }
      });

      const response = await this.docClient!.send(command);

      if (response.Item) {
        console.log(`‚úÖ AWS: Retrieved paper trading data for user ${userId}`);
        return response.Item.data;
      }

      console.log(`‚ö†Ô∏è AWS: No paper trading data found for user ${userId}`);
      return null;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to get paper trading data for user ${userId}:`, error);
      return null;
    }
  }

  async deletePaperTradingData(userId: string): Promise<boolean> {
    if (!this.isConnected()) {
      console.error("‚ùå AWS DynamoDB not connected");
      return false;
    }

    try {
      const paperTradingKey = `paper_trading_${userId}`;
      const command = new DeleteCommand({
        TableName: TABLE_NAME,
        Key: { dateKey: paperTradingKey }
      });

      await this.docClient!.send(command);
      console.log(`‚úÖ AWS: Deleted paper trading data for user ${userId}`);
      return true;
    } catch (error) {
      console.error(`‚ùå AWS: Failed to delete paper trading data for user ${userId}:`, error);
      return false;
    }
  }
}

export const awsDynamoDBService = new AWSDynamoDBService();
